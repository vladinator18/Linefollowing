#!/usr/bin/env python3
"""
EROBOTA16 - ROG ALLY CONTROLLER V4 (Stable)
- HIGH SPEED: Uses 115200 Baud
- SMOOTHING: Prevents power spikes when both motors start
- DUAL STICK: Left stick drive, Right stick turn
"""

import tkinter as tk
from tkinter import ttk, messagebox
import serial
import serial.tools.list_ports
import time
import pygame
import threading

class RobotController:
    def __init__(self):
        self.ser = None
        self.connected = False
        self.invert_left = False
        self.invert_right = False
        self.last_send_time = 0
        self.send_interval = 0.03  # Limit sends to ~30Hz to prevent flooding
        
    def find_arduino(self):
        ports = serial.tools.list_ports.comports()
        for p in ports:
            if any(x in p.description for x in ['Arduino', 'CH340', 'USB Serial', 'CP210']):
                return p.device
        return None
    
    def connect(self, port, baud=115200):
        """Connect to Arduino at High Speed"""
        try:
            self.ser = serial.Serial(port, baud, timeout=1)
            self.connected = True
            time.sleep(2) 
            return True
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def disconnect(self):
        if self.ser and self.ser.is_open:
            self.send_command(0, 0, force=True)
            time.sleep(0.1)
            self.ser.close()
        self.connected = False
    
    def send_command(self, left, right, force=False):
        """Send L/R speeds to Arduino with Rate Limiting"""
        if not self.connected: return False
        
        current_time = time.time()
        if not force and (current_time - self.last_send_time < self.send_interval):
            return False
            
        if self.ser and self.ser.is_open:
            try:
                # Apply Inversions
                l_final = -left if self.invert_left else left
                r_final = -right if self.invert_right else right
                
                cmd = f"L:{int(l_final)};R:{int(r_final)}\n"
                self.ser.write(cmd.encode())
                self.last_send_time = current_time
                return True
            except:
                return False
        return False

class JoystickHandler:
    def __init__(self, callback):
        self.callback = callback
        self.joystick = None
        self.running = True
        
        self.axis_speed = 1 
        self.axis_turn = 2 
        
        # Tuning
        self.deadzone = 0.10
        self.turn_sensitivity = 0.7
        self.speed_limit = 1.0
        self.smoothing = 0.2 # 0.0 = Instant, 0.9 = Very Slow
        
        # State for smoothing
        self.current_l = 0.0
        self.current_r = 0.0
        
        pygame.init()
        pygame.joystick.init()
        
        self.thread = threading.Thread(target=self.joystick_loop, daemon=True)
        self.thread.start()
    
    def update_settings(self, turn_sens, speed_lim, deadzone, smooth, s_axis, t_axis):
        self.turn_sensitivity = turn_sens
        self.speed_limit = speed_lim
        self.deadzone = deadzone
        self.smoothing = smooth
        try:
            self.axis_speed = int(s_axis)
            self.axis_turn = int(t_axis)
        except:
            pass
    
    def apply_deadzone(self, value):
        if abs(value) < self.deadzone: return 0.0
        sign = 1 if value > 0 else -1
        scaled = (abs(value) - self.deadzone) / (1.0 - self.deadzone)
        return sign * scaled
    
    def calculate_motor_speeds(self, speed_val, turn_val):
        throttle = -speed_val
        turn = turn_val
        
        throttle = self.apply_deadzone(throttle)
        turn = self.apply_deadzone(turn)
        
        throttle *= self.speed_limit
        turn_input = turn * self.turn_sensitivity
        
        # Mixing
        left_target = throttle + turn_input
        right_target = throttle - turn_input
        
        # Normalize
        max_val = max(abs(left_target), abs(right_target))
        if max_val > 1.0:
            left_target /= max_val
            right_target /= max_val
            
        # Apply Smoothing (Low Pass Filter)
        # New = Old + Factor * (Target - Old)
        # Factor 1.0 = Instant, Factor 0.1 = Slow
        factor = 1.0 - self.smoothing
        self.current_l += factor * (left_target - self.current_l)
        self.current_r += factor * (right_target - self.current_r)
        
        # Convert
        left_speed = int(self.current_l * 255)
        right_speed = int(self.current_r * 255)
        
        return left_speed, right_speed

    def joystick_loop(self):
        while self.running:
            try:
                if pygame.joystick.get_count() > 0:
                    if self.joystick is None:
                        self.joystick = pygame.joystick.Joystick(0)
                        self.joystick.init()
                    
                    pygame.event.pump()
                    
                    num_axes = self.joystick.get_numaxes()
                    raw_speed = self.joystick.get_axis(self.axis_speed) if self.axis_speed < num_axes else 0.0
                    raw_turn = self.joystick.get_axis(self.axis_turn) if self.axis_turn < num_axes else 0.0
                    
                    all_axes = [self.joystick.get_axis(i) for i in range(min(num_axes, 6))]

                    l_pwm, r_pwm = self.calculate_motor_speeds(raw_speed, raw_turn)
                    self.callback(l_pwm, r_pwm, all_axes)
                else:
                    self.joystick = None
                    self.callback(0, 0, [])
                
                time.sleep(0.02) # 50Hz Loop
            except Exception as e:
                print(f"Joy error: {e}")
                time.sleep(0.1)
    
    def stop(self):
        self.running = False

class RogAllyUI:
    def __init__(self, root):
        self.root = root
        self.root.title("EROBOTA16 - STABLE CONTROL")
        self.root.geometry("1000x800")
        self.root.configure(bg='#0d1117')
        
        self.controller = RobotController()
        
        self.bg_dark = '#0d1117'
        self.bg_card = '#161b22'
        self.accent_red = '#ff0a54'
        self.accent_cyan = '#00d9ff'
        self.accent_green = '#00ff88'
        self.text_white = '#ffffff'
        self.text_gray = '#8b949e'
        
        self.current_left = 0
        self.current_right = 0
        self.raw_axes = []
        
        self.create_ui()
        self.joystick_handler = JoystickHandler(self.on_joystick_update)
        self.update_loop()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def on_joystick_update(self, l_pwm, r_pwm, all_axes):
        self.current_left = l_pwm
        self.current_right = r_pwm
        self.raw_axes = all_axes
        # Send to Arduino
        self.controller.send_command(l_pwm, r_pwm)
    
    def update_settings(self, _=None):
        try:
            t_sens = self.turn_scale.get()
            s_lim = self.speed_scale.get()
            dead = self.dead_scale.get()
            smooth = self.smooth_scale.get()
            
            s_axis = int(self.axis_speed_combo.get().split(" ")[0])
            t_axis = int(self.axis_turn_combo.get().split(" ")[0])
            
            self.joystick_handler.update_settings(t_sens, s_lim, dead, smooth, s_axis, t_axis)
            
            self.controller.invert_left = self.inv_left_var.get()
            self.controller.invert_right = self.inv_right_var.get()
        except:
            pass

    def create_ui(self):
        header = tk.Frame(self.root, bg=self.bg_card, height=80)
        header.pack(fill=tk.X, padx=15, pady=15)
        
        t_frame = tk.Frame(header, bg=self.bg_card)
        t_frame.pack(side=tk.LEFT, padx=20, pady=10)
        tk.Label(t_frame, text="EROBOTA16", font=("Arial Black", 24), fg=self.accent_red, bg=self.bg_card).pack(anchor='w')
        tk.Label(t_frame, text="HIGH SPEED + SMOOTHING", font=("Arial", 10, "bold"), fg=self.accent_green, bg=self.bg_card).pack(anchor='w')

        c_frame = tk.Frame(header, bg=self.bg_card)
        c_frame.pack(side=tk.RIGHT, padx=20)
        self.port_combo = ttk.Combobox(c_frame, width=15, state='readonly')
        self.port_combo.pack(side=tk.LEFT, padx=5)
        tk.Button(c_frame, text="âŸ³", command=self.refresh_ports, bg=self.bg_card, fg=self.accent_cyan).pack(side=tk.LEFT)
        self.connect_btn = tk.Button(c_frame, text="CONNECT", command=self.toggle_connection, bg=self.accent_red, fg=self.text_white)
        self.connect_btn.pack(side=tk.LEFT, padx=10)
        self.refresh_ports()

        content = tk.Frame(self.root, bg=self.bg_dark)
        content.pack(fill=tk.BOTH, expand=True, padx=15)

        left_col = tk.Frame(content, bg=self.bg_dark)
        left_col.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)

        scanner_frame = tk.LabelFrame(left_col, text="Axis Scanner", bg=self.bg_dark, fg=self.accent_cyan)
        scanner_frame.pack(fill=tk.X, pady=10)
        self.axis_labels = []
        for i in range(6):
            lbl = tk.Label(scanner_frame, text=f"Axis {i}: 0.00", bg=self.bg_dark, fg=self.text_gray, font=("Courier", 10))
            lbl.pack(anchor='w', padx=10)
            self.axis_labels.append(lbl)

        tk.Label(left_col, text="MOTOR OUTPUT", font=("Arial", 12, "bold"), fg=self.accent_green, bg=self.bg_dark).pack(pady=(20,5))
        self.l_bar = tk.Canvas(left_col, height=30, bg=self.bg_card, highlightthickness=0)
        self.l_bar.pack(fill=tk.X, padx=10, pady=5)
        self.r_bar = tk.Canvas(left_col, height=30, bg=self.bg_card, highlightthickness=0)
        self.r_bar.pack(fill=tk.X, padx=10, pady=5)

        right_col = tk.Frame(content, bg=self.bg_card, width=350)
        right_col.pack(side=tk.RIGHT, fill=tk.BOTH, expand=False, padx=10, pady=10)
        right_col.pack_propagate(False)
        
        tk.Label(right_col, text="ðŸŽ® MAPPING", font=("Arial", 12, "bold"), fg=self.text_white, bg=self.bg_card).pack(pady=10)
        axis_opts = [f"{i} (Generic)" for i in range(6)]
        
        tk.Label(right_col, text="Speed Axis (Left Stick Y)", fg=self.text_gray, bg=self.bg_card).pack(anchor='w', padx=20)
        self.axis_speed_combo = ttk.Combobox(right_col, values=axis_opts, state='readonly')
        self.axis_speed_combo.set("1 (Generic)")
        self.axis_speed_combo.pack(fill=tk.X, padx=20, pady=(0, 10))
        self.axis_speed_combo.bind("<<ComboboxSelected>>", self.update_settings)

        tk.Label(right_col, text="Turn Axis (Right Stick X)", fg=self.text_gray, bg=self.bg_card).pack(anchor='w', padx=20)
        self.axis_turn_combo = ttk.Combobox(right_col, values=axis_opts, state='readonly')
        self.axis_turn_combo.set("2 (Generic)")
        self.axis_turn_combo.pack(fill=tk.X, padx=20, pady=(0, 10))
        self.axis_turn_combo.bind("<<ComboboxSelected>>", self.update_settings)

        tk.Label(right_col, text="âš™ TUNING", font=("Arial", 12, "bold"), fg=self.text_white, bg=self.bg_card).pack(pady=10)

        def make_slider(label, vmin, vmax, vdef, res):
            f = tk.Frame(right_col, bg=self.bg_card)
            f.pack(fill=tk.X, padx=20, pady=5)
            tk.Label(f, text=label, fg=self.text_gray, bg=self.bg_card).pack(anchor='w')
            s = tk.Scale(f, from_=vmin, to=vmax, orient=tk.HORIZONTAL, resolution=res, bg=self.bg_card, fg=self.text_white, highlightthickness=0, command=self.update_settings)
            s.set(vdef)
            s.pack(fill=tk.X)
            return s

        self.smooth_scale = make_slider("Smoothing (Prevent Spikes)", 0.0, 0.95, 0.3, 0.05)
        self.turn_scale = make_slider("Turn Sensitivity", 0.1, 1.0, 0.7, 0.05)
        self.speed_scale = make_slider("Max Speed Limit", 0.1, 1.0, 1.0, 0.1)
        self.dead_scale = make_slider("Deadzone", 0.0, 0.3, 0.1, 0.01)

        self.inv_left_var = tk.BooleanVar()
        tk.Checkbutton(right_col, text="Invert Left", variable=self.inv_left_var, bg=self.bg_card, fg=self.accent_cyan, selectcolor=self.bg_dark, command=self.update_settings).pack(anchor='w', padx=20)
        self.inv_right_var = tk.BooleanVar()
        tk.Checkbutton(right_col, text="Invert Right", variable=self.inv_right_var, bg=self.bg_card, fg=self.accent_cyan, selectcolor=self.bg_dark, command=self.update_settings).pack(anchor='w', padx=20)

        self.status_lbl = tk.Label(self.root, text="Ready", bg=self.accent_cyan)
        self.status_lbl.pack(side=tk.BOTTOM, fill=tk.X)

    def refresh_ports(self):
        ports = [p.device for p in serial.tools.list_ports.comports()]
        self.port_combo['values'] = ports
        if ports: self.port_combo.current(0)
        auto = self.controller.find_arduino()
        if auto and auto in ports: self.port_combo.set(auto)

    def toggle_connection(self):
        if not self.controller.connected:
            if self.controller.connect(self.port_combo.get()):
                self.connect_btn.config(text="DISCONNECT", bg=self.accent_green)
                self.status_lbl.config(text="CONNECTED (115200)", bg=self.accent_green)
            else:
                messagebox.showerror("Error", "Failed")
        else:
            self.controller.disconnect()
            self.connect_btn.config(text="CONNECT", bg=self.accent_red)
            self.status_lbl.config(text="DISCONNECTED", bg=self.accent_red)

    def draw_bar(self, canvas, val):
        canvas.delete('all')
        w = canvas.winfo_width()
        center = w/2
        norm = val/255.0
        length = norm * (w/2)
        color = self.accent_green if val >= 0 else self.accent_red
        canvas.create_rectangle(center, 0, center+length, 30, fill=color)
        canvas.create_line(center, 0, center, 30, fill='white')

    def update_loop(self):
        for i, val in enumerate(self.raw_axes):
            if i < len(self.axis_labels):
                bg = self.bg_card if abs(val) > 0.1 else self.bg_dark
                fg = self.accent_green if abs(val) > 0.1 else self.text_gray
                self.axis_labels[i].config(text=f"Axis {i}: {val:+.2f}", bg=bg, fg=fg)

        self.draw_bar(self.l_bar, self.current_left)
        self.draw_bar(self.r_bar, self.current_right)
        self.root.after(50, self.update_loop)

    def on_closing(self):
        self.joystick_handler.stop()
        self.controller.disconnect()
        pygame.quit()
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    RogAllyUI(root)
    root.mainloop()
