#!/usr/bin/env python3
"""
EROBOTA16 - ROG ALLY JOYSTICK CONTROL
Uses ROG Ally's built-in joysticks for differential drive control
Left stick for movement, visual feedback on screen
"""

import tkinter as tk
from tkinter import ttk, messagebox
import serial
import serial.tools.list_ports
import time
import pygame
import threading

class RobotController:
    def __init__(self):
        self.ser = None
        self.connected = False
        self.base_speed = 0  # Forward/backward from Y-axis
        self.turn_value = 0   # Left/right from X-axis
        
    def find_arduino(self):
        """Auto-detect Arduino port"""
        ports = serial.tools.list_ports.comports()
        for p in ports:
            if any(x in p.description for x in ['Arduino', 'CH340', 'USB Serial', 'CP210']):
                return p.device
        return None
    
    def connect(self, port, baud=9600):
        """Connect to Arduino"""
        try:
            self.ser = serial.Serial(port, baud, timeout=1)
            self.connected = True
            time.sleep(2)
            return True
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def disconnect(self):
        """Disconnect and stop motors"""
        if self.ser and self.ser.is_open:
            self.send_command(0, 0)
            time.sleep(0.1)
            self.ser.close()
        self.connected = False
    
    def send_command(self, speed, turn):
        """Send command to Arduino"""
        if self.ser and self.ser.is_open:
            try:
                cmd = f"SPD:{speed};TURN:{turn}\n"
                self.ser.write(cmd.encode())
                return True
            except:
                return False
        return False
    
    def update_motors(self):
        """Send current joystick values to motors"""
        if not self.connected:
            return None, None
        
        self.send_command(self.base_speed, self.turn_value)
        
        # Calculate displayed wheel speeds
        left_speed = max(-255, min(255, self.base_speed + self.turn_value))
        right_speed = max(-255, min(255, self.base_speed - self.turn_value))
        
        return left_speed, right_speed

class JoystickHandler:
    def __init__(self, callback):
        self.callback = callback
        self.joystick = None
        self.running = True
        self.deadzone = 0.15  # Ignore small movements
        
        pygame.init()
        pygame.joystick.init()
        
        self.thread = threading.Thread(target=self.joystick_loop, daemon=True)
        self.thread.start()
    
    def joystick_loop(self):
        """Background thread to read joystick input"""
        while self.running:
            try:
                # Check for joystick connection
                if pygame.joystick.get_count() > 0:
                    if self.joystick is None:
                        self.joystick = pygame.joystick.Joystick(0)
                        self.joystick.init()
                        print(f"Joystick connected: {self.joystick.get_name()}")
                    
                    pygame.event.pump()
                    
                    # Read left stick (stick 0)
                    # X-axis: -1 (left) to +1 (right)
                    # Y-axis: -1 (up) to +1 (down)
                    x_axis = self.joystick.get_axis(0)
                    y_axis = self.joystick.get_axis(1)
                    
                    # Apply deadzone
                    if abs(x_axis) < self.deadzone:
                        x_axis = 0
                    if abs(y_axis) < self.deadzone:
                        y_axis = 0
                    
                    # Convert to robot commands
                    # Y-axis controls speed (inverted: up = forward)
                    base_speed = int(-y_axis * 255)
                    
                    # X-axis controls turning
                    turn_value = int(x_axis * 120)
                    
                    # Send to callback
                    self.callback(base_speed, turn_value, x_axis, y_axis)
                    
                else:
                    if self.joystick is not None:
                        self.joystick = None
                        print("Joystick disconnected")
                    self.callback(0, 0, 0, 0)
                
                time.sleep(0.02)  # 50Hz update rate
                
            except Exception as e:
                print(f"Joystick error: {e}")
                time.sleep(0.1)
    
    def stop(self):
        self.running = False

class RogAllyUI:
    def __init__(self, root):
        self.root = root
        self.root.title("EROBOTA16 - ROG ALLY CONTROL")
        self.root.geometry("900x700")
        self.root.configure(bg='#0d1117')
        self.root.resizable(False, False)
        
        self.controller = RobotController()
        
        # ROG Ally color scheme
        self.bg_dark = '#0d1117'
        self.bg_card = '#161b22'
        self.accent_red = '#ff0a54'
        self.accent_cyan = '#00d9ff'
        self.accent_green = '#00ff88'
        self.accent_orange = '#ff6b35'
        self.text_white = '#ffffff'
        self.text_gray = '#8b949e'
        
        self.joystick_x = 0
        self.joystick_y = 0
        
        self.create_ui()
        
        # Start joystick handler
        self.joystick_handler = JoystickHandler(self.on_joystick_update)
        
        self.update_loop()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def on_joystick_update(self, base_speed, turn_value, x_axis, y_axis):
        """Called when joystick values change"""
        self.controller.base_speed = base_speed
        self.controller.turn_value = turn_value
        self.joystick_x = x_axis
        self.joystick_y = y_axis
    
    def create_ui(self):
        # ============ HEADER ============
        header = tk.Frame(self.root, bg=self.bg_card, height=100)
        header.pack(fill=tk.X, padx=15, pady=15)
        header.pack_propagate(False)
        
        # Title
        title_frame = tk.Frame(header, bg=self.bg_card)
        title_frame.pack(side=tk.LEFT, padx=20)
        
        title = tk.Label(title_frame, text="EROBOTA16", 
                        font=("Arial Black", 28, "bold"),
                        fg=self.accent_red, bg=self.bg_card)
        title.pack(anchor='w')
        
        subtitle = tk.Label(title_frame, text="LEFT STICK ONLY CONTROL", 
                           font=("Arial", 11, "bold"),
                           fg=self.accent_cyan, bg=self.bg_card)
        subtitle.pack(anchor='w')
        
        drive_info = tk.Label(title_frame, text="Tank Drive â€¢ Full Control with One Joystick", 
                            font=("Arial", 8),
                            fg=self.text_gray, bg=self.bg_card)
        drive_info.pack(anchor='w')
        
        # Connection panel
        conn_panel = tk.Frame(header, bg=self.bg_dark, relief=tk.RAISED, bd=2)
        conn_panel.pack(side=tk.RIGHT, padx=20, pady=10)
        
        port_frame = tk.Frame(conn_panel, bg=self.bg_dark)
        port_frame.pack(padx=15, pady=10)
        
        tk.Label(port_frame, text="PORT:", font=("Arial", 9, "bold"),
                fg=self.text_gray, bg=self.bg_dark).grid(row=0, column=0, padx=5)
        
        self.port_var = tk.StringVar()
        self.port_combo = ttk.Combobox(port_frame, textvariable=self.port_var, 
                                       width=18, state='readonly')
        self.port_combo.grid(row=0, column=1, padx=5)
        self.refresh_ports()
        
        btn_frame = tk.Frame(conn_panel, bg=self.bg_dark)
        btn_frame.pack(padx=15, pady=(0, 10))
        
        refresh_btn = tk.Button(btn_frame, text="âŸ³ REFRESH", 
                               command=self.refresh_ports,
                               bg=self.bg_card, fg=self.accent_cyan,
                               font=("Arial", 9, "bold"),
                               relief=tk.FLAT, cursor='hand2', padx=10)
        refresh_btn.pack(side=tk.LEFT, padx=3)
        
        self.connect_btn = tk.Button(btn_frame, text="â— CONNECT",
                                     command=self.toggle_connection,
                                     bg=self.accent_red, fg=self.text_white,
                                     font=("Arial", 10, "bold"),
                                     relief=tk.FLAT, cursor='hand2', padx=15, pady=5)
        self.connect_btn.pack(side=tk.LEFT, padx=3)
        
        # ============ MAIN DISPLAY AREA ============
        main_container = tk.Frame(self.root, bg=self.bg_dark)
        main_container.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        # Left side - Joystick visualization
        left_panel = tk.Frame(main_container, bg=self.bg_dark)
        left_panel.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=10)
        
        tk.Label(left_panel, text="ðŸŽ® LEFT STICK", 
                font=("Arial", 16, "bold"),
                fg=self.accent_cyan, bg=self.bg_dark).pack(pady=10)
        
        # Joystick visualization canvas
        self.joystick_canvas = tk.Canvas(left_panel, width=300, height=300,
                                         bg=self.bg_card, highlightthickness=3,
                                         highlightbackground=self.accent_cyan)
        self.joystick_canvas.pack(pady=20)
        
        # Draw joystick base
        self.joystick_canvas.create_oval(20, 20, 280, 280, 
                                         outline=self.accent_cyan, width=3)
        self.joystick_canvas.create_oval(40, 40, 260, 260, 
                                         outline=self.accent_cyan, width=1)
        
        # Draw crosshair
        self.joystick_canvas.create_line(150, 30, 150, 270, 
                                         fill=self.text_gray, width=1, dash=(5, 5))
        self.joystick_canvas.create_line(30, 150, 270, 150, 
                                         fill=self.text_gray, width=1, dash=(5, 5))
        
        # Joystick indicator (will be updated)
        self.joystick_indicator = self.joystick_canvas.create_oval(
            135, 135, 165, 165,
            fill=self.accent_red, outline=self.text_white, width=2
        )
        
        # Direction labels
        self.joystick_canvas.create_text(150, 15, text="FORWARD", 
                                         font=("Arial", 9, "bold"), fill=self.text_gray)
        self.joystick_canvas.create_text(150, 285, text="REVERSE", 
                                         font=("Arial", 9, "bold"), fill=self.text_gray)
        self.joystick_canvas.create_text(15, 150, text="L", 
                                         font=("Arial", 12, "bold"), fill=self.text_gray)
        self.joystick_canvas.create_text(285, 150, text="R", 
                                         font=("Arial", 12, "bold"), fill=self.text_gray)
        
        # Joystick values display
        values_frame = tk.Frame(left_panel, bg=self.bg_card)
        values_frame.pack(pady=10, fill=tk.X, padx=20)
        
        self.joy_status = tk.Label(values_frame, text="Waiting for joystick...",
                                   font=("Arial", 11, "bold"),
                                   fg=self.accent_orange, bg=self.bg_card, pady=10)
        self.joy_status.pack()
        
        # Right side - Motor status and speedometer
        right_panel = tk.Frame(main_container, bg=self.bg_dark)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10)
        
        # Speedometer
        tk.Label(right_panel, text="âš¡ POWER", 
                font=("Arial", 16, "bold"),
                fg=self.accent_green, bg=self.bg_dark).pack(pady=10)
        
        self.speed_canvas = tk.Canvas(right_panel, width=220, height=220,
                                      bg=self.bg_card, highlightthickness=0)
        self.speed_canvas.pack(pady=10)
        
        # Draw speedometer
        self.speed_canvas.create_oval(10, 10, 210, 210, 
                                      outline=self.accent_red, width=4)
        self.speed_canvas.create_oval(25, 25, 195, 195, 
                                      outline=self.accent_red, width=1)
        
        self.speed_arc = self.speed_canvas.create_arc(15, 15, 205, 205,
                                                      start=90, extent=0,
                                                      outline=self.accent_green,
                                                      width=10, style=tk.ARC)
        
        self.speed_text = self.speed_canvas.create_text(110, 95,
                                                        text="0",
                                                        font=("Arial Black", 52, "bold"),
                                                        fill=self.text_white)
        
        self.speed_canvas.create_text(110, 140, text="POWER %",
                                      font=("Arial", 11, "bold"),
                                      fill=self.accent_cyan)
        
        # Motor status
        motor_frame = tk.Frame(right_panel, bg=self.bg_dark)
        motor_frame.pack(pady=20, fill=tk.X)
        
        # Left motor
        left_motor = tk.Frame(motor_frame, bg=self.bg_card, relief=tk.RAISED, bd=2)
        left_motor.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5)
        
        tk.Label(left_motor, text="â—€ LEFT", 
                font=("Arial", 10, "bold"),
                fg=self.accent_cyan, bg=self.bg_card).pack(pady=5)
        
        self.left_bar = tk.Canvas(left_motor, height=30, bg=self.bg_dark,
                                 highlightthickness=0)
        self.left_bar.pack(fill=tk.X, padx=10, pady=5)
        
        self.left_text = tk.Label(left_motor, text="0",
                                 font=("Courier New", 14, "bold"),
                                 fg=self.text_white, bg=self.bg_card)
        self.left_text.pack(pady=5)
        
        # Right motor
        right_motor = tk.Frame(motor_frame, bg=self.bg_card, relief=tk.RAISED, bd=2)
        right_motor.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5)
        
        tk.Label(right_motor, text="RIGHT â–¶", 
                font=("Arial", 10, "bold"),
                fg=self.accent_cyan, bg=self.bg_card).pack(pady=5)
        
        self.right_bar = tk.Canvas(right_motor, height=30, bg=self.bg_dark,
                                  highlightthickness=0)
        self.right_bar.pack(fill=tk.X, padx=10, pady=5)
        
        self.right_text = tk.Label(right_motor, text="0",
                                  font=("Courier New", 14, "bold"),
                                  fg=self.text_white, bg=self.bg_card)
        self.right_text.pack(pady=5)
        
        # Instructions
        instructions = tk.Frame(self.root, bg=self.bg_card, relief=tk.RAISED, bd=2)
        instructions.pack(fill=tk.X, padx=20, pady=10)
        
        inst_text = """ðŸŽ® LEFT JOYSTICK ONLY CONTROL
        â¬† UP = Forward â€¢ â¬‡ DOWN = Reverse â€¢ â¬… LEFT = Turn Left â€¢ âž¡ RIGHT = Turn Right
        â†–â†— DIAGONALS = Move + Turn â€¢ âŠ™ CENTER = Stop"""
        
        tk.Label(instructions, text=inst_text,
                font=("Arial", 10, "bold"),
                fg=self.text_white, bg=self.bg_card, pady=15).pack()
        
        # Status bar
        self.status_bar = tk.Label(self.root, text="â— DISCONNECTED",
                                   font=("Arial", 11, "bold"),
                                   fg=self.accent_red, bg=self.bg_card, pady=12)
        self.status_bar.pack(fill=tk.X, side=tk.BOTTOM)
    
    def refresh_ports(self):
        ports = [p.device for p in serial.tools.list_ports.comports()]
        self.port_combo['values'] = ports
        if ports:
            self.port_combo.current(0)
        
        auto_port = self.controller.find_arduino()
        if auto_port and auto_port in ports:
            self.port_combo.set(auto_port)
    
    def toggle_connection(self):
        if not self.controller.connected:
            port = self.port_var.get()
            if not port:
                messagebox.showerror("Error", "Select a port first")
                return
            
            if self.controller.connect(port):
                self.connect_btn.config(text="â— DISCONNECT", bg=self.accent_green)
                self.status_bar.config(text="â— CONNECTED - Ready to drive!", 
                                      fg=self.accent_green)
                self.port_combo.config(state='disabled')
            else:
                messagebox.showerror("Error", "Connection failed")
        else:
            self.controller.disconnect()
            self.connect_btn.config(text="â— CONNECT", bg=self.accent_red)
            self.status_bar.config(text="â— DISCONNECTED", fg=self.accent_red)
            self.port_combo.config(state='readonly')
    
    def update_motor_bar(self, canvas, speed):
        canvas.delete('bar')
        w = canvas.winfo_width()
        bar_w = abs(speed) / 255 * w
        color = self.accent_green if speed >= 0 else self.accent_orange
        canvas.create_rectangle(0, 0, bar_w, 30, fill=color, tags='bar')
    
    def update_loop(self):
        # Update joystick visualization
        center_x = 150
        center_y = 150
        radius = 110
        
        pos_x = center_x + (self.joystick_x * radius)
        pos_y = center_y + (self.joystick_y * radius)
        
        self.joystick_canvas.coords(self.joystick_indicator,
                                    pos_x - 15, pos_y - 15,
                                    pos_x + 15, pos_y + 15)
        
        # Update joystick status
        if pygame.joystick.get_count() > 0:
            joy_name = pygame.joystick.Joystick(0).get_name()
            status_text = f"ðŸŽ® {joy_name}\nX: {self.joystick_x:+.2f} | Y: {self.joystick_y:+.2f}"
            self.joy_status.config(text=status_text, fg=self.accent_green)
        else:
            self.joy_status.config(text="âš  No joystick detected\nConnect ROG Ally controller", 
                                  fg=self.accent_orange)
        
        # Update motors
        if self.controller.connected:
            result = self.controller.update_motors()
            if result[0] is not None:
                left, right = result
                
                # Update speedometer
                speed_pct = int(abs(self.controller.base_speed) / 255 * 100)
                self.speed_canvas.itemconfig(self.speed_text, text=str(speed_pct))
                
                extent = -speed_pct * 3.6
                self.speed_canvas.itemconfig(self.speed_arc, extent=extent)
                
                # Update motor bars
                self.update_motor_bar(self.left_bar, left)
                self.left_text.config(text=str(left))
                
                self.update_motor_bar(self.right_bar, right)
                self.right_text.config(text=str(right))
        
        self.root.after(50, self.update_loop)
    
    def on_closing(self):
        self.joystick_handler.stop()
        self.controller.disconnect()
        pygame.quit()
        self.root.destroy()

def main():
    root = tk.Tk()
    app = RogAllyUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
